/*!
 * TIFANY.js - Table Input Formatter and ANalYzer
 * Version: 2.0.0
 * Author: Bonzai Carn
 * License: MIT
 * Repository: https://github.com/Bonzai2Carn/TIFANY
 * 
 * A lightweight, jQuery-based table editor with advanced manipulation features
 * 
 * Features:
 * - Smart table parsing (HTML, ASCII, CSV, Text)
 * - Visual grid mapping for complex structures
 * - Undo/Redo history management
 * - Drag & drop row/column reordering
 * - Cell/Row/Column operations
 * - Table transpose
 * - Crosshair highlighting
 * - Tab-based column visibility (sp-selector)
 * - Accordion panels
 * - CSS styling and class management
 * 
 * Dependencies:
 * - jQuery >= 3.6.0
 * - Bootstrap >= 4.1.3 (optional, for modals)
 * - Popper.js v1.x (included with Bootstrap 4.1.3)
 */

(function (factory) {
    'use strict';

    // UMD (Universal Module Definition) pattern for compatibility
    if (typeof define === 'function' && define.amd) {
        // AMD (RequireJS)
        define(['jquery'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS/Node.js
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    'use strict';

    // ===================================================================================
    // NAMESPACE & VERSION
    // ===================================================================================

    const TIFANY = {
        version: '2.0.0',
        options: {
            maxHistory: 50,
            autoSave: true,
            enableDragDrop: false,
            enableCrosshair: false,
            defaultTableClass: 'tablecoil crosshair-table'
        }
    };

    // ===================================================================================
    // 1. VISUAL GRID MAPPER CLASS
    // ===================================================================================

    class VisualGridMapper {
        constructor(table) {
            this.table = table instanceof jQuery ? table[0] : table;
            this.grid = [];
            this.cellMap = new Map();
            this.buildGrid();
        }

        buildGrid() {
            const $table = $(this.table);
            const rows = $table.find('tr');
            let maxCols = 0;

            rows.each((rowIndex, row) => {
                this.grid[rowIndex] = this.grid[rowIndex] || [];
            });

            rows.each((rowIndex, row) => {
                let colIndex = 0;
                $(row).find('td, th').each((cellIndex, cell) => {
                    const $cell = $(cell);
                    const colspan = parseInt($cell.attr('colspan') || 1);
                    const rowspan = parseInt($cell.attr('rowspan') || 1);

                    while (this.grid[rowIndex][colIndex] !== undefined) {
                        colIndex++;
                    }

                    this.cellMap.set(cell, {
                        rowspan: rowspan,
                        colspan: colspan,
                        content: $cell.html(),
                        isHeader: $cell.is('th'),
                        startRow: rowIndex,
                        startCol: colIndex
                    });

                    for (let r = 0; r < rowspan; r++) {
                        this.grid[rowIndex + r] = this.grid[rowIndex + r] || [];
                        for (let c = 0; c < colspan; c++) {
                            this.grid[rowIndex + r][colIndex + c] = {
                                element: cell,
                                isOrigin: (r === 0 && c === 0)
                            };
                        }
                    }

                    colIndex += colspan;
                });

                maxCols = Math.max(maxCols, colIndex);
            });

            this.maxCols = maxCols;
            this.maxRows = this.grid.length;
        }

        getCellsInRow(rowIndex) {
            const cells = new Set();
            if (this.grid[rowIndex]) {
                this.grid[rowIndex].forEach(gridCell => {
                    if (gridCell) {
                        cells.add(gridCell.element);
                    }
                });
            }
            return Array.from(cells);
        }

        getCellsInColumn(colIndex) {
            const cells = new Set();
            this.grid.forEach(row => {
                if (row && row[colIndex]) {
                    cells.add(row[colIndex].element);
                }
            });
            return Array.from(cells);
        }

        getVisualPosition(cell) {
            return this.cellMap.get(cell);
        }
    }

    // ===================================================================================
    // 2. TABLE HISTORY MANAGER CLASS
    // ===================================================================================

    class TableHistoryManager {
        constructor(maxHistory = 50) {
            this.history = [];
            this.currentIndex = -1;
            this.maxHistory = maxHistory;
            this.isRestoring = false;
        }

        saveState(tableHtml) {
            if (this.isRestoring || !tableHtml || tableHtml.trim() === '') return;
            if (this.currentIndex >= 0 && this.history[this.currentIndex] === tableHtml) return;

            this.history = this.history.slice(0, this.currentIndex + 1);
            this.history.push(tableHtml);

            if (this.history.length > this.maxHistory) {
                this.history.shift();
            } else {
                this.currentIndex++;
            }

            this.updateHistoryUI();
        }

        undo() {
            if (this.canUndo()) {
                this.currentIndex--;
                this.updateHistoryUI();
                return this.history[this.currentIndex];
            }
            return null;
        }

        redo() {
            if (this.canRedo()) {
                this.currentIndex++;
                this.updateHistoryUI();
                return this.history[this.currentIndex];
            }
            return null;
        }

        canUndo() {
            return this.currentIndex > 0;
        }

        canRedo() {
            return this.currentIndex < this.history.length - 1;
        }

        clear() {
            this.history = [];
            this.currentIndex = -1;
            this.updateHistoryUI();
        }

        updateHistoryUI() {
            const undoCount = this.currentIndex;
            const redoCount = this.history.length - this.currentIndex - 1;

            $('.undoState').text(`${undoCount} available`);
            $('.redoState').text(`${redoCount} available`);

            $('.undoHistory').prop('disabled', !this.canUndo()).css('opacity', this.canUndo() ? '1' : '0.5');
            $('.redoHistory').prop('disabled', !this.canRedo()).css('opacity', this.canRedo() ? '1' : '0.5');
        }
    }

    // ===================================================================================
    // 3. TIFANY CORE CLASS
    // ===================================================================================

    class TifanyCore {
        constructor(container, options) {
            this.container = $(container);
            this.options = $.extend({}, TIFANY.options, options);
            this.currentTable = null;
            this.selectedCells = [];
            this.historyManager = new TableHistoryManager(this.options.maxHistory);
            this.crosshairEnabled = this.options.enableCrosshair;
            this.dragDropEnabled = this.options.enableDragDrop;

            this.init();
        }

        init() {
            this.initializeFeatures();
            this.attachEventHandlers();
        }

        initializeFeatures() {
            this.initAccordions();
            this.initSpSelectors();
            this.initHeaderAccordion();

            if (this.crosshairEnabled) {
                this.initCrosshair();
            }
        }

        // ===================================================================================
        // ACCORDION FUNCTIONALITY
        // ===================================================================================

        initAccordions() {
            $(document).off('click.tifany-accordion').on('click.tifany-accordion', '.accordion-header', function () {
                $(this).toggleClass('actives');
                $(this).closest('tr').nextUntil('.accordion-header').toggle();
            });
        }

        initHeaderAccordion() {
            $(document).off('click.tifany-header-accordion').on('click.tifany-header-accordion', '.accordion', function () {
                $(this).toggleClass('active');
                const $panel = $(this).next('.panel');
                $panel.slideToggle(200);
            });
            // Activate specific panels on initialization
            $('.accordion').each(function (index) {
                // Add logic to determine which panels to toggle on
                if ($(this).hasClass('active')) {
                    $(this).next('.panel').slideToggle(200); // Show the panel
                }
            });
        }

        // ===================================================================================
        // SP-SELECTOR FUNCTIONALITY (Column Visibility Toggle)
        // ===================================================================================

        initSpSelectors() {
            $(document).off('click.tifany-sp-selector').on('click.tifany-sp-selector', '.sp-option', function () {
                const $option = $(this);
                const panel = $option.closest('.panel');
                const table = panel.find('.tablecoil');
                const spValue = $option.data('value');

                panel.find('.sp-option').removeClass('active');
                $option.addClass('active');

                table.find('[class*="sp-"]').removeClass('active');
                table.find(`.sp-${spValue}`).addClass('active');
            });
        }

        // ===================================================================================
        // CROSSHAIR FUNCTIONALITY
        // ===================================================================================

        initCrosshair() {
            const self = this;

            $(document).off('mouseenter.tifany-crosshair mouseleave.tifany-crosshair')
                .on('mouseenter.tifany-crosshair', '.crosshair-table td, .crosshair-table th', function () {
                    if (!self.crosshairEnabled || !self.currentTable) return;

                    const hoveredCell = this;
                    const $table = $(self.currentTable);
                    const mapper = new VisualGridMapper($table);
                    const position = mapper.cellMap.get(hoveredCell);

                    if (!position) return;

                    $table.find('.highlight-row, .highlight-col').removeClass('highlight-row highlight-col');

                    const rowCells = new Set();
                    const colCells = new Set();

                    for (let r = 0; r < position.rowspan; r++) {
                        mapper.getCellsInRow(position.startRow + r).forEach(cell => rowCells.add(cell));
                    }

                    for (let c = 0; c < position.colspan; c++) {
                        mapper.getCellsInColumn(position.startCol + c).forEach(cell => colCells.add(cell));
                    }

                    $(Array.from(rowCells)).addClass('highlight-row');
                    $(Array.from(colCells)).addClass('highlight-col');
                })
                .on('mouseleave.tifany-crosshair', '.crosshair-table', function () {
                    $(this).find('.highlight-row, .highlight-col').removeClass('highlight-row highlight-col');
                });
        }

        toggleCrosshair() {
            this.crosshairEnabled = !this.crosshairEnabled;
            const $table = $(this.currentTable);

            if (this.crosshairEnabled) {
                $table.addClass('crosshair-table');
                this.initCrosshair();
            } else {
                $table.removeClass('crosshair-table');
                $table.find('.highlight-row, .highlight-col').removeClass('highlight-row highlight-col');
            }
        }

        // ===================================================================================
        // TABLE TRANSPOSE
        // ===================================================================================

        transposeTable() {
            if (!this.currentTable) return;

            this.saveCurrentState();

            const $originalTable = $(this.currentTable);
            const mapper = new VisualGridMapper($originalTable);
            const grid = mapper.grid;
            const transposedGrid = [];

            for (let c = 0; c < mapper.maxCols; c++) {
                transposedGrid[c] = [];
                for (let r = 0; r < mapper.maxRows; r++) {
                    transposedGrid[c][r] = (grid[r] && grid[r][c]) ? grid[r][c] : null;
                }
            }

            const $transposedTable = $('<table>')
                .addClass($originalTable.attr('class'))
                .attr('id', $originalTable.attr('id'));

            const visited = new Set();

            transposedGrid.forEach((row, rowIndex) => {
                const $tr = $('<tr id="test">');

                row.forEach((gridCell, colIndex) => {
                    const key = `${rowIndex},${colIndex}`;
                    if (visited.has(key)) return;

                    if (!gridCell || !gridCell.element || !gridCell.isOrigin) {
                        if (!visited.has(key)) {
                            $tr.append('<td> </td>');
                        }
                        return;
                    }

                    const $originalCell = $(gridCell.element);
                    const cellInfo = mapper.cellMap.get(gridCell.element);
                    const newRowspan = cellInfo.colspan;
                    const newColspan = cellInfo.rowspan;

                    const $newCell = $(cellInfo.isHeader ? '<th>' : '<td>')
                        .addClass($originalCell.attr('class'))
                        .attr('id', $originalCell.attr('id'))
                        .html(cellInfo.content);

                    if (newRowspan > 1) $newCell.attr('rowspan', newRowspan);
                    if (newColspan > 1) $newCell.attr('colspan', newColspan);

                    $tr.append($newCell);

                    for (let r = 0; r < newRowspan; r++) {
                        for (let c = 0; c < newColspan; c++) {
                            visited.add(`${rowIndex + r},${colIndex + c}`);
                        }
                    }
                });

                const originalRow = $(row[0].element).closest('tr');
                $tr.addClass(originalRow.attr('class')).attr('id', originalRow.attr('id'));

                $transposedTable.append($tr);
            });

            $originalTable.replaceWith($transposedTable);
            this.currentTable = $transposedTable[0];
            this.initializeFeatures();
        }

        // ===================================================================================
        // STATE MANAGEMENT
        // ===================================================================================

        saveCurrentState() {
            if (this.currentTable && !this.historyManager.isRestoring) {
                const state = this.container.html();
                this.historyManager.saveState(state);
            }
        }

        performUndo() {
            const state = this.historyManager.undo();
            if (state) {
                this.historyManager.isRestoring = true;
                this.container.html(state);
                this.currentTable = this.container.find('table')[0];
                this.initializeFeatures();
                this.historyManager.isRestoring = false;
            }
        }

        performRedo() {
            const state = this.historyManager.redo();
            if (state) {
                this.historyManager.isRestoring = true;
                this.container.html(state);
                this.currentTable = this.container.find('table')[0];
                this.initializeFeatures();
                this.historyManager.isRestoring = false;
            }
        }

        // ===================================================================================
        // EVENT HANDLERS
        // ===================================================================================

        attachEventHandlers() {
            const self = this;

            // Accordion toggles
            this.initAccordions();
            this.initHeaderAccordion();
            this.initSpSelectors();
        }

        // ===================================================================================
        // PUBLIC API METHODS
        // ===================================================================================

        loadTable(tableHtml) {
            this.container.html(tableHtml);
            this.currentTable = this.container.find('table')[0];
            this.initializeFeatures();
            this.saveCurrentState();
        }

        getTableHTML() {
            return this.container.html();
        }

        destroy() {
            $(document).off('.tifany-accordion .tifany-header-accordion .tifany-sp-selector .tifany-crosshair');
            this.container.empty();
            this.historyManager.clear();
        }
    }

    // ===================================================================================
    // JQUERY PLUGIN INTERFACE
    // ===================================================================================

    $.fn.tifany = function (options) {
        return this.each(function () {
            const $this = $(this);
            let instance = $this.data('tifany');

            if (!instance) {
                instance = new TifanyCore(this, options);
                $this.data('tifany', instance);
            }

            return instance;
        });
    };

    // ===================================================================================
    // STATIC METHODS (Available globally)
    // ===================================================================================

    // Initialize all tables with specific classes automatically
    TIFANY.autoInit = function () {
        $('.crosshair-table, .tablecoil').each(function () {
            if (!$(this).data('tifany-initialized')) {
                const tifany = new TifanyCore(this, TIFANY.options);
                $(this).data('tifany-initialized', true);
                $(this).data('tifany-instance', tifany);
            }
        });
    };

    // Enable crosshair on specific table
    TIFANY.enableCrosshair = function (selector) {
        $(selector).each(function () {
            const instance = $(this).data('tifany-instance');
            if (instance) {
                instance.crosshairEnabled = true;
                instance.initCrosshair();
            } else {
                const tifany = new TifanyCore(this, { enableCrosshair: true });
                $(this).data('tifany-instance', tifany);
            }
        });
    };

    // Transpose table
    TIFANY.transpose = function (selector) {
        const instance = $(selector).data('tifany-instance');
        if (instance) {
            instance.transposeTable();
        }
    };

    // ===================================================================================
    // AUTO-INITIALIZATION ON DOM READY
    // ===================================================================================

    $(document).ready(function () {
        // Auto-initialize tables with TIFANY classes
        TIFANY.autoInit();

        // Make sp-selectors work automatically
        $(document).on('click', '.sp-option', function () {
            const $option = $(this);
            const panel = $option.closest('.panel');
            const table = panel.find('.tablecoil, .crosshair-table');
            const spValue = $option.data('value');

            panel.find('.sp-option').removeClass('active');
            $option.addClass('active');

            table.find('[class*="sp-"]').removeClass('active');
            table.find(`.sp-${spValue}`).addClass('active');
        });

        // Make accordions work automatically
        $(document).on('click', '.accordion', function () {
            $(this).toggleClass('active');
            const $panel = $(this).next('.panel');
            $panel.slideToggle(200);
        });

        // Make accordion-headers work automatically
        $(document).on('click', '.accordion-header', function () {
            $(this).toggleClass('actives');
            $(this).closest('tr').nextUntil('.accordion-header').toggle();
        });
    });

    // ===================================================================================
    // EXPOSE TO GLOBAL SCOPE
    // ===================================================================================

    window.TIFANY = TIFANY;
    window.VisualGridMapper = VisualGridMapper;
    window.TableHistoryManager = TableHistoryManager;

    return TIFANY;
}));

/*!
 * End of TIFANY.js
 */